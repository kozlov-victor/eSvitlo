import * as path from 'path';
import * as fs from 'fs/promises';
import * as ESLintPlugin from 'eslint-webpack-plugin';
import {fileURLToPath} from 'url';
import * as zlib from 'zlib';

const MINIMIZE = true;

const bufferAsCppCode = (buff)=>{
    const size = Buffer.byteLength(buff);
    const lines = [`\n    {`];
    let cnt = 0;
    for (const x of buff) {
        lines.push(
            '0x'+x.toString(16).padStart(2, '0') + (cnt<size-1?', ':'')
        );
        cnt++;
        if (cnt===500) {
            cnt = 0;
            lines.push('\n    ');
        }
    }
    lines.push('}');
    return lines.join('');
}

const zip = (buff)=> {
    return zlib.gzipSync(buff, { level: 9 });
}

const copyResourcesToCpp = async ()=>{
    const assetsBin = [];
    const eTag = new Date().getTime()+'';

    let indexHtml = await fs.readFile('./index.html','utf8');
    indexHtml =
        indexHtml.replaceAll('${build_no}',eTag);
    assetsBin.push({
        gzip: true,
        buff: Buffer.from(indexHtml, 'utf-8'),
        name: 'assets_index_html',
        mime: "text/html",
    });
    assetsBin.push({
        gzip: true,
        buff: await fs.readFile('./out/index.js'),
        name: 'assets_index_js',
        mime: "text/javascript",
    });
    assetsBin.push({
        gzip: true,
        buff: await fs.readFile('./out/all.css'),
        name: 'assets_all_css',
        mime: "text/css",
    });

    for (let f of await fs.readdir('./src/assets')) {
        const buff = await fs.readFile(`./src/assets/${f}`);
        assetsBin.push({
            gzip: false,
            buff,
            name:'assets_'+f.replaceAll('.','_'),
            mime: "image/png",
        });
    }

    for (const assetsBinElement of assetsBin) {
        if (assetsBinElement.gzip) {
            assetsBinElement.buff = zip(assetsBinElement.buff);
        }
    }

    const cppSource =
        `
// this file is autogenerated!
// don't change it!

#ifndef SVITLO_STATIC_H
#define SVITLO_STATIC_H
#include <Arduino.h>
#include <stdint.h>  // Додаємо цей заголовок для типів uint8_t, uint16_t тощо
#include "../server/v_static/v_static.h"

const String E_TAG = "${eTag}";

${assetsBin.map(f=>{
            return `
    
const uint8_t __${f.name}__[] PROGMEM = ${bufferAsCppCode(f.buff)};    
    
const V_FILE ${f.name} = 
{
    "${f.mime}",
    __${f.name}__,
    ${f.gzip ?? false},
    ${Buffer.byteLength(f.buff)}
};
    `;
        }).join('\n')}

#endif
`;

    await fs.writeFile('../src/app/libs/static/static.h',cppSource,{encoding:'utf8'});
}

class WebpackDonePlugin{
    apply(compiler){
        compiler.hooks.done.tap('compilation',  (stats)=> {
            setTimeout(async ()=>{
                if (stats.compilation.errors && stats.compilation.errors.length) {
                    console.error('compiled with errors');
                } else {
                    copyResourcesToCpp();
                    console.log(`compiled at ${new Date()}`);
                }
            },10);
        });
    }
}

class ImportCssPlugin {
    constructor(options = {}) {
        this.decoratorName = options.decoratorName || "CSS";
        this.output = options.output || "bundle.css";
    }

    async exists(path) {
        try {
            await fs.stat(path);
            return true;
        } catch {
            return false;
        }
    }

    apply(compiler) {
        compiler.hooks.emit.tapAsync("DIStylesPlugin", async (compilation, callback) => {
            const cssContents = [];

            const modulesToCheck = new Set();

            //
            // Нормальні модулі Webpack
            //
            for (const module of compilation.modules) {
                if (module.resource) {
                    modulesToCheck.add({
                        file: module.resource,
                        source: module.originalSource().source().toString()
                    });
                }
            }

            //
            // Додаємо ENTRY-файли вручну
            //
            const entry = compilation.options.entry;

            const entryFiles = this._extractEntryFiles(entry);
            for (const entryPath of entryFiles) {
                const abs = path.resolve(compiler.context, entryPath);
                if (await this.exists(abs)) {
                    modulesToCheck.add({
                        file: abs,
                        source: await fs.readFile(abs, "utf8")
                    });
                }
            }

            for (const { file, source } of modulesToCheck) {
                if (!source) continue;

                const fileDir = path.dirname(file);

                // --- декоратори ---
                const decoratorRegex = new RegExp(
                    `\\bDI\\.${this.decoratorName}\\((['"])(.*?)\\1\\)`,
                    "g"
                );

                let match;
                while ((match = decoratorRegex.exec(source))) {
                    const rel = match[2];
                    const abs = path.resolve(fileDir, rel);
                    if (await this.exists(abs)) {
                        compilation.fileDependencies.add(abs);
                        cssContents.push(await fs.readFile(abs, "utf8"));
                    } else {
                        compilation.errors.push(
                            new Error(`DIStylesPlugin: CSS file not found: ${abs}`)
                        );
                    }
                }
            }

            for (const module of modulesToCheck) {

                const fileDir = path.dirname(module.file);

                let source;
                try {
                    if (module.originalSource) {
                        source = module.originalSource().source().toString();
                    } else if (module._source && module._source._value) {
                        source = module._source._value.toString();
                    }
                } catch {
                    continue;
                }

                if (!source) continue;

                const decoratorRegex = new RegExp(
                    `\\bDI\\.${this.decoratorName}\\((['"])(.*?)\\1\\)`,
                    "g"
                );

                let match;
                while ((match = decoratorRegex.exec(source))) {
                    const cssRelPath = match[2];
                    const absPath = path.resolve(fileDir, cssRelPath);

                    if (await this.exists(absPath)) {
                        cssContents.push(await fs.readFile(absPath, "utf8"));
                    } else {
                        compilation.errors.push(
                            new Error(`DIStylesPlugin: CSS file not found: ${absPath}`)
                        );
                    }
                }
            }

            // ---- Фінальний bundle.css ----
            let finalCss = cssContents.join("\n");
            if (MINIMIZE) {

            }

            const { RawSource } = compiler.webpack.sources;
            compilation.emitAsset(this.output, new RawSource(finalCss));
            callback();
        });
    }

    _extractEntryFiles(entry) {
        if (typeof entry === "string") return [entry];
        if (Array.isArray(entry)) return entry;
        if (typeof entry === "object") {
            let result = [];
            for (const key of Object.keys(entry)) {
                result = result.concat(this._extractEntryFiles(entry[key]));
            }
            return result;
        }
        return [];
    }
}

export default async (env = {})=>{

    const entry = {};
    const output = {};

    entry['index'] = './src/index.ts';
    output.path = path.resolve('./out');

    output.filename = '[name].js';
    output.chunkFilename = "[name].chunk.js";

    const __dirname = path.dirname(fileURLToPath(import.meta.url));

    const config = {
        entry,
        output,
        target: ['web', 'es5'],
        mode: 'production', //debug ? 'development' : 'production',
        //devtool: 'inline-source-map',
        resolveLoader: {
            modules: ['node_modules', path.resolve(__dirname, 'node_tools/loaders')]
        },
        watchOptions: {
            aggregateTimeout: 2000,
            ignored: ['**/out/', '/node_modules/'],
        },
        performance: {
            maxEntrypointSize: 1024000,
            maxAssetSize: 1024000
        },
        module: {
            rules: [
                {
                    test: /\.txt/,
                    use: [
                        {loader: "txt/txt-loader",options: {}},
                    ]
                },
                {
                    test: /\.(png|jpe?g)$/,
                    use: [
                        {loader: 'base64/base64-loader',options: {}}
                    ]
                },
                {
                    test: /\.tsx$/,
                    enforce: 'pre',
                    use: [
                        {
                            loader: "ts-engine-precompiler/tsx-precompiler"
                        },
                    ]
                },
                {
                    test: /\.tsx?$/,
                    use: [
                        {
                            loader: "ts-loader",options: {},
                        },
                    ]
                },
            ]
        },
        resolve: {
            extensions: ['.ts','.tsx','.js'],
            modules: [
                path.resolve(__dirname, 'node_modules'),
            ],
            alias: {
                '@engine': path.resolve(__dirname, 'engine'),
            },
        },
        optimization: {
            minimize: MINIMIZE,
            emitOnErrors: false,
        },
    };

    config.plugins = [
        new ESLintPlugin.default({
            context: '../',
            emitError: true,
            emitWarning: true,
            failOnError: true,
            extensions: ["ts", "tsx"],
        }),
        new ImportCssPlugin({output: 'all.css'}),
        new WebpackDonePlugin(),
    ];

    return config;
}
